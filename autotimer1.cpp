#include "autotimer1.h"
/*
   Using Arduino.h for the digitalWrite function only.  Otherwise, use these
  #include <math.h>
  #include <avr/io.h>
  #include <avr/interrupt.h>

*/
#include <Arduino.h>

AutoTimer1::AutoTimer1() {
  frequency = 0;
  prescaler = 0;
  count = 0;
};

// gets the actual frequency generated by the current prescaler/count combination.
// This may differ from the frequency set with #setFrequency, depending on how accurately that time could be reflected in the Timer.
uint32_t AutoTimer1::actualFrequency() {
  if (count == 0 || prescaler == 0)
    return 0;
  uint32_t scaleCount = (uint32_t)prescaler * (uint32_t)count;
  return CLOCK_SPEED / scaleCount;
};


// Sets the current frequency for the timer to output on its output signal pin.
// Try each prescaler to get the closest result, setting both prescaler and count.
void AutoTimer1::setFrequency(uint32_t frequency) {
  resetTimer1();
  this->frequency = 0;
  this->prescaler = 0;
  this->count = 0;

  if (frequency < 1) {
    return;
  }

  double resultFreq = 0;    // accurate record of the best result so far.
  uint16_t resultScale = 0;
  uint16_t resultCount = 0;

  // Try each of the prescalers to see which produces the closes approximation of the requested frequency
  for (int index = 0; index < PRESCALER_COUNT; index++) {
    uint32_t cnt = calculateCount(prescalers[index], frequency);
    if (cnt == 0) // Can't prescale for this frequency
      continue;

    double actual = CLOCK_SPEED / (prescalers[index] * cnt);
    if (resultFreq == 0 || (abs(frequency - actual) < abs(frequency - resultFreq)) ) { // find first or closer match
      resultFreq = actual;
      resultScale = prescalers[index];
      resultCount = cnt;
      if (round(actual) == this->frequency) { // if hit the mark exactly, bail out.
        break;
      }
    }
  }
  this->frequency = frequency;
  this->prescaler = resultScale;
  this->count = resultCount;
}


// Calculate the count required to get given frequency using given prescaler.
// If result is bigger than 0xFFFF, returns zero.
uint32_t AutoTimer1::calculateCount(uint16_t prescale, uint32_t frequency) {
  if (prescale == 0 || frequency == 0)
    return 0;

  uint32_t cnt = CLOCK_SPEED / (prescale * frequency) - 1;
  return (cnt < 0xFFFF) ? cnt : 0; // only if it doesn't overflow
}

// Sets the CS12, CS11 & CS10 bits on TCCR1B for the given prescaler.
// If not a valid prescaler (found in prescalers[]) then disables the Timer by setting all bits to zero.
void AutoTimer1::setTimerPrescaler(uint16_t scaler) {
  switch (scaler) {
    case 1 :
      TCCR1B |= (1 << CS10);
      break;

    case 8 :
      TCCR1B |= (1 << CS11);
      break;

    case 64 :
      TCCR1B |= (1 << CS11);
      TCCR1B |= (1 << CS10);
      break;

    case 256 :
      TCCR1B |= (1 << CS12);
      break;

    case 1024 :
      TCCR1B |= (1 << CS12);
      TCCR1B |= (1 << CS10);
      break;

    default: // disable timer
      TCCR1B &= (0 << CS12);
      TCCR1B &= (0 << CS11);
      TCCR1B &= (0 << CS10);
  }
}


void AutoTimer1::startTimer1() {
  cli();

  resetTimer1();

  // turn on CTC mode. (reset timer counter when TOP(OCR1A) reached)
  TCCR1B |= (1 << WGM12);

  setTimerPrescaler(prescaler);

  // set compare match registers
  uint16_t start = Count() * PULSE_WIDTH;
  if (start > Count())
    start = 1;

  // Set outputcompares, OCR1A = full cycle, OCR1B when pulse starts.
  OCR1A = Count();
  OCR1B = start;

  TIMSK1 |= (1 << OCIE1A) | (1 << OCIE1B);  // enable 'On compare match' for COMPB

  sei();
}


void AutoTimer1::resetTimer1() {
  cli();

  // Clear control register
  TCCR1A = 0; // set entire TCCR1A register to 0
  TCCR1B = 0; // same for TCCR1B
  TCNT1  = 0; // initialize counter value to 0
  TIMSK1 = 0;

  TIFR1 |= (1 << ICF1); // clear Input Capture Flag
  TIFR1 |= (1 << TOV1); // clear Overflow Flag

  sei();
}

ISR(TIMER1_COMPA_vect) {
  digitalWrite(SIGNAL_PIN_OUT, HIGH);
}

ISR(TIMER1_COMPB_vect) {
  digitalWrite(SIGNAL_PIN_OUT, LOW);
}

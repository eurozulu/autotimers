
/**
   Open source library
   Copyright Rob Gilham 2020
*/

#include "autotimer.h"
/*
   Using Arduino.h for the digitalWrite function only.  Otherwise, use these
  #include <math.h>
  #include <avr/io.h>
  #include <avr/interrupt.h>

*/

AutoTimer::AutoTimer() {
  this->frequency = 0;
  this->prescaler = 0;
  this->count = 0;
};

// gets the actual frequency generated by the current prescaler/count combination.
// This may differ from the frequency set with #setFrequency, depending on how accurately that time could be reflected in the Timer.
uint32_t AutoTimer::actualFrequency() {
  if (count == 0 || prescaler == 0)
    return 0;
  return (CLOCK_SPEED / ((uint32_t)prescaler * count) / 2);
};

// Sets the current frequency for the timer to output on its output signal pin.
// Try each prescaler to get the closest result, setting both prescaler and count.
void AutoTimer::setFrequency(uint16_t frequency) {

  resetTimer(); // turn off the timer & reset it.
  this->frequency = 0;
  this->prescaler = 0;
  this->count = 0;

  double resultFreq = 0;    // accurate record (double) of the best result so far.
  uint16_t resultScale = 0;
  uint16_t resultCount = 0;

  if (frequency > 0) {
    float dblFreq = frequency * 2;

    // Try each of the prescalers to see which produces the closes approximation of the requested frequency
    for (int index = 0; index < prescalersLength(); index++) {
      uint16_t presclr = prescalers(index);

      uint16_t cnt = calculateCount(presclr, dblFreq);
      if (cnt == 0) // Can't prescale for this frequency
        continue;

      double actual = CLOCK_SPEED / ((double)presclr * cnt);

      if (resultFreq == 0 || (abs(frequency - (actual / 2)) < abs(frequency - (resultFreq / 2)) ) ) { // find first or closer match
        resultFreq = actual;
        resultScale = presclr;
        resultCount = cnt;
        if (round(actual / 2) == frequency) { // if hit the mark exactly, bail out.
          break;
        }
      }
    }
  }

  if (resultScale == 0) {
    return;
  }
  
  this->frequency = frequency;
  this->prescaler = resultScale;
  this->count = resultCount;

}


// Calculate the count required to get given frequency using given prescaler.
uint16_t AutoTimer::calculateCount(uint16_t prescale, float frequency) {
  if (prescale == 0 || frequency == 0)
    return 0;

  uint32_t cnt = CLOCK_SPEED / ((uint32_t)prescale * frequency) - 1;
  return (cnt < counterMaximum()) ? cnt : 0; // only if it doesn't overflow
}
